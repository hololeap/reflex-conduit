{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE RecursiveDo #-}

module Reflex.Conduit (
      runConduitReflex
    , runConduitReflexDebug
    , runConduitReflexFoo) where

import Control.Concurrent (forkIO)
--import Control.Concurrent.Async
--import Control.Concurrent.Chan (Chan, newChan, readChan, writeChan)
import Control.Monad (forever)
import Control.Monad.Fix
import Control.Monad.IO.Class (MonadIO, liftIO)
import Data.Conduit (ConduitT, runConduit, awaitForever, yield, (.|))
import Data.Functor (void)
import Reflex.Class (Event, ffor)
import Reflex.PerformEvent.Class (PerformEvent, Performable, performEvent_)
import Reflex.TriggerEvent.Class --(TriggerEvent, newTriggerEvent)
import UnliftIO


-- | Use an Event as input for a Conduit over the IO monad. Whenever output
-- | is produced, the new Event is triggered.
runConduitReflex ::
    (TriggerEvent t m, PerformEvent t m, MonadIO (Performable m), MonadIO m)
    => Event t i -> ConduitT i o IO () -> m (Event t o, Async (), Async ())
runConduitReflex inEvent conduit = do
    inChan  <- newInChan
    outChan <- newOutChan
    asncCond <- asyncRunConduit inChan outChan conduit
    readEventChan inEvent inChan
    (outEvent, asncWrite) <- writeEventChan outChan
    pure (outEvent, asncCond, asncWrite)

runConduitReflexDebug ::
    ( TriggerEvent t m, PerformEvent t m, MonadIO (Performable m), MonadIO m
    , Show i, Show o)
    => Event t i -> ConduitT i o IO () -> m (Event t o, Async (), Async ())
runConduitReflexDebug inEvent conduit = do
    inChan  <- newInChan
    outChan <- newOutChan
    asncCond <- asyncRunConduitDebug inChan outChan conduit
    readEventChanDebug inEvent inChan
    (outEvent, asncWrite) <- writeEventChanDebug outChan
    pure (outEvent, asncCond, asncWrite)

runConduitReflexFoo ::
    ( TriggerEvent t m, PerformEvent t m, MonadIO (Performable m), MonadIO m
    , Show o )
    => Event t i -> ConduitT i o IO () -> m (Event t o, Async ())
runConduitReflexFoo inEvent conduit = do
    inChan <- newInChan
    readEventChan inEvent inChan
    foo inChan conduit

-- | Runs in a seperate thread, passing values from the InChan to the Conduit,
-- | and passing resulting values from the Conduit to the OutChan.
asyncRunConduit :: MonadIO m 
    => InChan i -> OutChan o -> ConduitT i o IO () -> m (Async ())
asyncRunConduit inChan outChan conduit = liftAsync $ do
    runConduit $ 
           (forever $ readInChan inChan >>= yield)
        .| conduit
        .| awaitForever (liftIO . writeOutChan outChan)

foo :: (TriggerEvent t m, MonadIO m, Show o)
    => InChan i -> ConduitT i o IO () -> m (Event t o, Async ())
foo inChan conduit = do
    (outEvent, outTrigger) <- newTriggerEventWithOnComplete
    asnc <- liftAsync $ runConduit $
           (forever $ readInChan inChan >>= yield)
        .| conduit
        .| awaitForever (\o -> liftIO $ outTrigger o (print o))
    pure (outEvent, asnc)
        
    

asyncRunConduitDebug :: (MonadIO m, Show i, Show o)
    => InChan i -> OutChan o -> ConduitT i o IO () -> m (Async ())
asyncRunConduitDebug inChan outChan conduit = liftAsync $ runConduit $
               (forever $ do
                    i <- readInChan inChan
                    liftIO . putStrLn $ "asyncRunConduitDebug (Input) : " ++ show i
                    yield i)
            .| conduit
            .| awaitForever (\o -> liftIO $ do
                putStrLn $ "asyncRunConduitDebug (Output): " ++ show o
                writeOutChan outChan o)
    
-- | Whenever the input Event fires, it writes the value to InChan
-- | (Reads from the Event)
readEventChan :: (PerformEvent t m, MonadIO (Performable m)) 
    => Event t a -> InChan a -> m ()
readEventChan inEvent inChan =
    performEvent_ $ writeInChan inChan <$> inEvent

readEventChanDebug :: (PerformEvent t m, MonadIO (Performable m), Show a) 
    => Event t a -> InChan a -> m ()
readEventChanDebug inEvent inChan =
    performEvent_ $ ffor inEvent $ \a -> do
        liftIO $ putStrLn $ "readEventChanDebug : " ++ show a
        writeInChan inChan a

-- | Creates a new Event from the OutChan, which will fire whenever the Conduit
-- | produces a result. (Writes to the new Event)
writeEventChan :: (TriggerEvent t m, MonadIO m)
    => OutChan a -> m (Event t a, Async ())
writeEventChan outChan = do
    (outEvent, outTrigger) <- newTriggerEvent
    asnc <- liftAsync $ forever $ readOutChan outChan >>= outTrigger
    pure (outEvent, asnc)

writeEventChanDebug :: (TriggerEvent t m, MonadIO m, Show a) 
    => OutChan a -> m (Event t a, Async ())
writeEventChanDebug outChan = do
    (outEvent, outTrigger) <- newTriggerEvent
    asnc <- liftAsync $ forever $ do
        a <- readOutChan outChan
        putStrLn $ "writeEventChanDebug: " ++ show a
        outTrigger a
    pure (outEvent, asnc)

-- | Run liftIO after forking. Drops the returned ThreadId.
--liftAsync :: MonadIO m => IO () -> m (Async)
--liftAsync = 

liftAsync :: MonadIO m => IO a -> m (Async a)
liftAsync = liftIO . async


-----

newtype AsyncConduit = AsyncConduit { getAsyncConduit :: Async () }
newtype AsyncWrite   = AsyncWrite   { getAsyncWrite   :: Async () }

newtype AsyncsCR     = AsyncsCR (AsyncConduit, AsyncWrite)

runAsyncsCR :: (MonadUnliftIO m, MonadFix m)
    => (m AsyncConduit) -> (m AsyncWrite) -> m AsyncsCR
runAsyncsCR mc mw = mdo
    ac <- finally mc (cancelAW aw)
    aw <- finally mw (cancelAC ac)
    pure $ AsyncsCR (ac, aw)
    
cancelAC :: MonadIO m => AsyncConduit -> m ()
cancelAC = cancel . getAsyncConduit

cancelAW :: MonadIO m => AsyncWrite -> m ()
cancelAW = cancel . getAsyncWrite

-----
-- Just to make sure the Chans aren't getting mixed up

-- InChan is the flow of values going into the Conduit
newtype InChan  a = InChan  { getInChan  :: Chan a }

-- OutChan is the flow of values coming out of the Conduit
newtype OutChan a = OutChan { getOutChan :: Chan a }

newInChan :: MonadIO m => m (InChan a)
newInChan = liftIO $ InChan <$> newChan

newOutChan :: MonadIO m => m (OutChan a)
newOutChan = liftIO $ OutChan <$> newChan

readInChan :: MonadIO m => InChan a -> m a
readInChan = liftIO . readChan . getInChan

readOutChan :: MonadIO m => OutChan a -> m a
readOutChan = liftIO . readChan . getOutChan

writeInChan :: MonadIO m => InChan a -> a -> m ()
writeInChan c = liftIO . writeChan (getInChan c)

writeOutChan :: MonadIO m => OutChan a -> a -> m ()
writeOutChan c = liftIO . writeChan (getOutChan c)
